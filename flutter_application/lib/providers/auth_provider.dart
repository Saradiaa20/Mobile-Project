import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../services/supabase_service.dart';

// Stream of auth state changes
final authStateProvider = StreamProvider<AuthState>((ref) {
  return SupabaseService.client.auth.onAuthStateChange;
});

// Current session
final sessionProvider = Provider<Session?>((ref) {
  final authState = ref.watch(authStateProvider).value;
  return authState?.session ?? Supabase.instance.client.auth.currentSession;
});

// Current user from session
final currentUserProvider = Provider<User?>((ref) {
  final session = ref.watch(sessionProvider);
  return session?.user;
});

// User profile from database
final userProfileProvider = FutureProvider<Map<String, dynamic>?>((ref) async {
  final user = ref.watch(currentUserProvider);
  if (user == null) return null;

  try {
    final response = await SupabaseService.client
        .from('profiles')
        .select()
        .eq('id', user.id)
        .single();
    return response;
  } catch (e) {
    print('Error fetching user profile: $e');
    return null;
  }
});

// Auth controller
final authControllerProvider = Provider<AuthController>((ref) {
  return AuthController();
});

class AuthController {
  final _client = SupabaseService.client;

  /// Sign in with email and password
  Future<void> signIn({
    required String email,
    required String password,
  }) async {
    try {
      await _client.auth.signInWithPassword(
        email: email,
        password: password,
      );
    } catch (e) {
      print('Sign in error: $e');
      rethrow;
    }
  }

  /// Sign up new user (customer or brand)
  Future<void> signUp({
    required String email,
    required String password,
    required String username,
    String? role,
    String? brandName, // Optional: only for brand owners
  }) async {
    try {
      // Normalize role to match database constraint (user, brand, admin)
      final normalizedRole = _normalizeRole(role);

      // Sign up with Supabase Auth
      final response = await _client.auth.signUp(
        email: email,
        password: password,
        data: {
          'username': username,
          'role': normalizedRole,
        },
      );

      if (response.user != null) {
        final userId = response.user!.id;

        // Create profile in database
        await _client.from('profiles').insert({
          'id': userId,
          'username': username,
          'role': normalizedRole,
        });

        print('User profile created successfully');

        // If signing up as brand owner, create brand record
        if (normalizedRole == 'brand') {
          await _client.from('brandowner').insert({
            // brandid will be auto-generated by Supabase (UUID)
            'id': userId, // Link to profiles.id
            'brandname':
                brandName ?? username, // Use username if no brand name provided
          });

          print('Brand record created successfully');
        }
      }
    } catch (e) {
      print('Sign up error: $e');
      rethrow;
    }
  }

  /// Send password reset email
  Future<void> resetPassword(String email) async {
    try {
      await _client.auth.resetPasswordForEmail(
        email,
        redirectTo: 'io.supabase.golocal://reset-callback/',
      );
    } catch (e) {
      print('Password reset error: $e');
      rethrow;
    }
  }

  /// Sign out current user
  Future<void> signOut() async {
    try {
      await _client.auth.signOut();
    } catch (e) {
      print('Sign out error: $e');
      rethrow;
    }
  }

  /// Update user profile
  Future<void> updateProfile({
    required String userId,
    String? username,
    String? role,
  }) async {
    try {
      final updates = <String, dynamic>{};
      if (username != null) updates['username'] = username;
      if (role != null) updates['role'] = _normalizeRole(role);

      await _client.from('profiles').update(updates).eq('id', userId);
    } catch (e) {
      print('Update profile error: $e');
      rethrow;
    }
  }

  /// Get brand ID for a brand owner
  Future<String?> getBrandId(String userId) async {
    try {
      final response = await _client
          .from('brandowner')
          .select('brandid')
          .eq('id', userId)
          .single();

      return response['brandid'] as String?;
    } catch (e) {
      print('Get brand ID error: $e');
      return null;
    }
  }

  /// Normalize role to match database constraint
  String _normalizeRole(String? role) {
    if (role == null) return 'user';

    final normalized = role.toLowerCase().trim();

    switch (normalized) {
      case 'admin':
      case 'administrator':
        return 'admin';
      case 'brand':
      case 'brand_owner':
      case 'brandowner':
        return 'brand';
      case 'user':
      case 'customer':
      default:
        return 'user';
    }
  }

  /// Check if user has specific role
  Future<bool> hasRole(String userId, String role) async {
    try {
      final profile = await _client
          .from('profiles')
          .select('role')
          .eq('id', userId)
          .single();

      return profile['role'] == _normalizeRole(role);
    } catch (e) {
      print('Check role error: $e');
      return false;
    }
  }
}
